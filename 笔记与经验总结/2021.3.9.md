# 2021.3.9
## 今日开发主题
自己编写一个 SVD 算法程序，加深对 SVD 算法的理解。
## 经验总结
编写 SVD 参考的文档：https://www.cnblogs.com/pinard/p/6251584.html

17:00 - 编写的代码
```matlab
function singularValueMatrix=homemade_svd(matrixToCompute)
    matrixA = matrixToCompute.'*matrixToCompute;
    matrixB = matrixToCompute*matrixToCompute.';
    % 记待求矩阵为A，求解A'A和AA'
    [eigVecA,eigValueA]=eig(matrixA);
    [eigVecB,eigValueB]=eig(matrixB);
%     % 对特征值和特征向量做排序
%     % 排序算法来自 https://ww2.mathworks.cn/help/matlab/ref/eig.html
%     [eigValueElementA,sortedIndexA] = sort(diag(eigValueA),'descend');
%     sortedEigValA=eigValueA(sortedIndexA,sortedIndexA);
%     sortedEigVecA = eigVecA(:,sortedIndexA);
%     
%     % 对 matrixB 的特征值和特征向量做同样的排序操作
%     [eigValueElementB,sortedIndexB] = sort(diag(eigValueB),'descend');
%     sortedEigValB=eigValueB(sortedIndexB,sortedIndexB);
%     sortedEigVecB = eigVecB(:,sortedIndexB);
    
    singularValueMatrix=sqrt(eigValueB(:,2:end))

    eigVecB*singularValueMatrix*eigVecA.'
end
```
在编写时遇到的问题：

本程序的思路，是通过求矩阵 A 与其转置的乘积 AA<sup>T</sup> 和 A<sup>T</sup>A 的特征值、特征向量，

来求解 A 矩阵的左奇异矩阵、奇异值矩阵和右奇异矩阵。

程序实现中借助了 MATLAB 的 eig() 函数来实现求特征值和特征向量。

然而它返回的特征值矩阵，其特征值的顺序与待求矩阵的奇异值顺序不一致。

例如在命令行执行：
```
svm=homemade_svd([0 1;1 1;1 0])
```
返回结果如下：
```


singularValueMatrix =

         0         0
    1.0000         0
         0    1.7321


ans =

    1.0000   -0.0000
    1.0000    1.0000
    0.0000    1.0000
```
这里我们可以看到，用代码求解出的左右奇异矩阵和奇异值矩阵，尝试恢复原先的矩阵，

恢复的结果恰好交换了两列的位置。

`singularValueMatrix` 是求解的奇异值矩阵，它本应为
```
    1.7321         0
         0    1.0000
         0         0
```
19:58 - 编写的代码
```matlab
function singularValueMatrix=homemade_svd(matrixToCompute)
    matrixA = matrixToCompute.'*matrixToCompute;
    matrixB = matrixToCompute*matrixToCompute.';
    % 记待求矩阵为A，求解A'A和AA'
    [eigVecA,eigValueA]=eig(matrixA);
    [eigVecB,eigValueB]=eig(matrixB);
    % 对特征值和特征向量做排序
    % 排序算法来自 https://ww2.mathworks.cn/help/matlab/ref/eig.html
    [eigValueElementA,sortedIndexA] = sort(diag(eigValueA),'descend');
    sortedEigValA=eigValueA(sortedIndexA,sortedIndexA);
    sortedEigVecA = eigVecA(:,sortedIndexA);
    
    % 对 matrixB 的特征值和特征向量做同样的排序操作
    [eigValueElementB,sortedIndexB] = sort(diag(eigValueB),'descend');
    sortedEigValB=eigValueB(sortedIndexB,sortedIndexB);
    sortedEigVecB = eigVecB(:,sortedIndexB);
    
    % 此处的截断仅仅是为了得到正确的奇异值矩阵而写的，没有一般性，需要修改。
    singularValueMatrix=sqrt(sortedEigValB(:,2:end))

    sortedEigVecB*singularValueMatrix*sortedEigVecA.'
end
```
编写完成之后，我们在调试中发现，左奇异矩阵 `sortedEigVecB` 的第二列与标准答案相差一个负号。

在特征值分解当中，相差一个负号不影响这个向量是矩阵的特征向量，但在奇异值分解的过程中，

这个负号使得
```
sortedEigVecB*singularValueMatrix*sortedEigVecA.'
```
恢复原矩阵的结果，与 SVD 前的原始矩阵相比互换了两列的位置。

手工纠正了这个负号以后，上式正确地恢复出了原始矩阵。

20:59 - 编写的代码
```matlab
function homemade_svd(matrixToCompute)
    matrixA = matrixToCompute'*matrixToCompute;
    matrixB = matrixToCompute*matrixToCompute';
    % 记待求矩阵为A，求解A'A和AA'
    [eigVecA,eigValueA]=eig(matrixA);
    [eigVecB,eigValueB]=eig(matrixB);
    ANS=eigVecB*d00iag([1 -1 1])*singularValueMatrix*eigVecA'
end 
```
对比 17:00 和 19:58 的代码及其运行结果，

我推测这两份代码无法得到正确结果的原因与 sort() 函数是否使用无关，

仅仅是由于左奇异矩阵 `eigVecB` 的第二列多一个负号所致。

果然，仅仅是比 17:00 时的代码多出纠正`eigVecB` 第二列的负号这一步，

代码就运行得到了正确的结果，`ANS` 与 SVD 前的矩阵完全相同。

综合上述事实，我得出结论：虽然特征值分解时，特征向量的符号并不是一个有明显影响的因素，

但在借助特征值分解的方法做奇异值分解时，每一个特征向量的符号都必须是“正确的”，才能保证 SVD 得到正确的左右奇异矩阵和奇异值矩阵。

## 待解决的问题
通过 eig() 函数获取符号正确的左右奇异矩阵的方法，目前暂时找不到。

这会导致 eig() 解出的左右奇异矩阵无法与奇异值矩阵一起还原出原始矩阵。

这是目前的主要问题。

从 eig() 解出特征值矩阵后，如何从特征值矩阵（方阵）获取奇异值矩阵（非方阵），也是一个问题。

目前使用的截断方法不具有一般性，需要找到一个能从任何尺寸的特征值矩阵求出任何尺寸的奇异值矩阵的方法。
