# 2021.3.9
## 今日开发主题
自己编写一个 SVD 算法程序，加深对 SVD 算法的理解。
## 经验总结
编写 SVD 参考的文档：https://www.cnblogs.com/pinard/p/6251584.html

17:00 - 编写的代码
```matlab
function singularValueMatrix=homemade_svd(matrixToCompute)
    matrixA = matrixToCompute.'*matrixToCompute;
    matrixB = matrixToCompute*matrixToCompute.';
    % 记待求矩阵为A，求解A'A和AA'
    [eigVecA,eigValueA]=eig(matrixA);
    [eigVecB,eigValueB]=eig(matrixB);
%     % 对特征值和特征向量做排序
%     % 排序算法来自 https://ww2.mathworks.cn/help/matlab/ref/eig.html
%     [eigValueElementA,sortedIndexA] = sort(diag(eigValueA),'descend');
%     sortedEigValA=eigValueA(sortedIndexA,sortedIndexA);
%     sortedEigVecA = eigVecA(:,sortedIndexA);
%     
%     % 对 matrixB 的特征值和特征向量做同样的排序操作
%     [eigValueElementB,sortedIndexB] = sort(diag(eigValueB),'descend');
%     sortedEigValB=eigValueB(sortedIndexB,sortedIndexB);
%     sortedEigVecB = eigVecB(:,sortedIndexB);
    
    singularValueMatrix=sqrt(eigValueB(:,2:end))

    eigVecB*singularValueMatrix*eigVecA.'
end
```
在编写时遇到的问题：

本程序的思路，是通过求矩阵 A 与其转置的乘积 AA<sup>T</sup> 和 A<sup>T</sup>A 的特征值、特征向量，

来求解 A 矩阵的左奇异矩阵、奇异值矩阵和右奇异矩阵。

程序实现中借助了 MATLAB 的 eig() 函数来实现求特征值和特征向量。

然而它返回的特征值矩阵，其特征值的顺序与待求矩阵的奇异值顺序不一致。

例如在命令行执行：
```
svm=homemade_svd([0 1;1 1;1 0])
```
返回结果如下：
```


singularValueMatrix =

         0         0
    1.0000         0
         0    1.7321


ans =

    1.0000   -0.0000
    1.0000    1.0000
    0.0000    1.0000
```
这里我们可以看到，用代码求解出的左右奇异矩阵和奇异值矩阵，尝试恢复原先的矩阵，

恢复的结果恰好交换了两列的位置。

`singularValueMatrix` 是求解的奇异值矩阵，它本应为
```
    1.7321         0
         0    1.0000
         0         0
```
19:58 - 编写的代码
```matlab
function singularValueMatrix=homemade_svd(matrixToCompute)
    matrixA = matrixToCompute.'*matrixToCompute;
    matrixB = matrixToCompute*matrixToCompute.';
    % 记待求矩阵为A，求解A'A和AA'
    [eigVecA,eigValueA]=eig(matrixA);
    [eigVecB,eigValueB]=eig(matrixB);
    % 对特征值和特征向量做排序
    % 排序算法来自 https://ww2.mathworks.cn/help/matlab/ref/eig.html
    [eigValueElementA,sortedIndexA] = sort(diag(eigValueA),'descend');
    sortedEigValA=eigValueA(sortedIndexA,sortedIndexA);
    sortedEigVecA = eigVecA(:,sortedIndexA);
    
    % 对 matrixB 的特征值和特征向量做同样的排序操作
    [eigValueElementB,sortedIndexB] = sort(diag(eigValueB),'descend');
    sortedEigValB=eigValueB(sortedIndexB,sortedIndexB);
    sortedEigVecB = eigVecB(:,sortedIndexB);
    
    % 此处的截断仅仅是为了得到正确的奇异值矩阵而写的，没有一般性，需要修改。
    singularValueMatrix=sqrt(sortedEigValB(:,2:end))

    sortedEigVecB*singularValueMatrix*sortedEigVecA.'
end
```
编写完成之后，我们在调试中发现，左奇异矩阵 `sortedEigVecB` 的第二列与标准答案相差一个负号。

在特征值分解当中，相差一个负号不影响这个向量是矩阵的特征向量，但在奇异值分解的过程中，

这个负号使得
```
sortedEigVecB*singularValueMatrix*sortedEigVecA.'
```
恢复原矩阵的结果的第二列与 SVD 前的原始矩阵相差了一个负号。

手工纠正了这个负号以后，上式正确地恢复出了原始矩阵。
